From 7e5fb3b5ef2187cb1db549b774ac5424577ca7f2 Mon Sep 17 00:00:00 2001
From: Brian Bockelman <bbockelm@cse.unl.edu>
Date: Wed, 10 Jul 2019 12:44:15 -0500
Subject: [PATCH 1/3] Avoid appending opaque information twice.

The opaque info gets appended later on in the function a second time.
---
 src/XrdHttp/XrdHttpReq.cc | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/XrdHttp/XrdHttpReq.cc b/src/XrdHttp/XrdHttpReq.cc
index cd5e293a82e..d6bff3c449a 100644
--- a/src/XrdHttp/XrdHttpReq.cc
+++ b/src/XrdHttp/XrdHttpReq.cc
@@ -688,7 +688,7 @@ bool XrdHttpReq::Redir(XrdXrootd::Bridge::Context &info, //!< the result context
     redirdest += buf;
   }
 
-  redirdest += resourceplusopaque.c_str();
+  redirdest += resource.c_str();
   
   // Here we put back the opaque info, if any
   if (vardata) {

From 8b7e413c78bbd251356fd3c05b1440adf3e5dbd4 Mon Sep 17 00:00:00 2001
From: Brian Bockelman <bbockelm@cse.unl.edu>
Date: Wed, 10 Jul 2019 12:44:43 -0500
Subject: [PATCH 2/3] The "resource plus opaque" string should not unquote
 info.

Without this, the opaque information kept in the resource string
is not a valid resource URL.  This differs from how the header2cgi
worked, which copies over opaque information quoted.
---
 src/XrdHttp/XrdHttpReq.cc | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/XrdHttp/XrdHttpReq.cc b/src/XrdHttp/XrdHttpReq.cc
index d6bff3c449a..f5685d30638 100644
--- a/src/XrdHttp/XrdHttpReq.cc
+++ b/src/XrdHttp/XrdHttpReq.cc
@@ -899,7 +899,7 @@ void XrdHttpReq::parseResource(char *res) {
     buf = unquote(p + 1);
     opaque = new XrdOucEnv(buf);
     resourceplusopaque.append('?');
-    resourceplusopaque.append(buf);
+    resourceplusopaque.append(p + 1);
     free(buf);
   }
   

From dd1432e193de36dbbf7caa974ac2639e79feaa65 Mon Sep 17 00:00:00 2001
From: Brian Bockelman <bbockelm@cse.unl.edu>
Date: Wed, 10 Jul 2019 14:09:57 -0500
Subject: [PATCH 3/3] Cleanly merge the opaque data and hdr2cgi data when
 redirecting.

Without this, the hdr2cgi data is dropped on a redirect.
---
 src/XrdHttp/XrdHttpReq.cc | 29 +++++++++++++++++------------
 src/XrdHttp/XrdHttpReq.hh |  1 +
 2 files changed, 18 insertions(+), 12 deletions(-)

diff --git a/src/XrdHttp/XrdHttpReq.cc b/src/XrdHttp/XrdHttpReq.cc
index f5685d30638..05f3a6fb447 100644
--- a/src/XrdHttp/XrdHttpReq.cc
+++ b/src/XrdHttp/XrdHttpReq.cc
@@ -271,21 +271,19 @@ int XrdHttpReq::parseLine(char *line, int len) {
     } else if (!strcasecmp(key, "Transfer-Encoding") && strstr(val, "chunked")) {
       m_transfer_encoding_chunked = true;
     } else {
-      // Some headers need to be translated into "local" cgi info. In theory they should already be quoted
+      // Some headers need to be translated into "local" cgi info.
       std::map< std:: string, std:: string > ::iterator it = prot->hdr2cgimap.find(key);
-      if (it != prot->hdr2cgimap.end()) {
+      if (it != prot->hdr2cgimap.end() && (opaque ? (0 == opaque->Get(it->second.c_str())) : true)) {
         std:: string s;
         s.assign(val, line+len-val);
         trim(s);
-        
+
         if (hdr2cgistr.length() > 0) {
           hdr2cgistr.append("&");
         }
         hdr2cgistr.append(it->second);
         hdr2cgistr.append("=");
         hdr2cgistr.append(s);
-        
-          
       }
     }
 
@@ -735,13 +733,23 @@ void XrdHttpReq::appendOpaque(XrdOucString &s, XrdSecEntity *secent, char *hash,
   if (opaque)
     p = opaque->Env(l);
 
-  if ((l < 2) && !hash) return;
+  if (hdr2cgistr.empty() && (l < 2) && !hash) return;
 
   // this works in most cases, except if the url already contains the xrdhttp tokens
   s = s + "?";
+  if (!hdr2cgistr.empty()) {
+    char *s1 = quote(hdr2cgistr.c_str());
+    if (s1) {
+        s += s1;
+        free(s1);
+    }
+  }
   if (p && (l > 1)) {
     char *s1 = quote(p+1);
     if (s1) {
+      if (!hdr2cgistr.empty()) {
+        s = s + "&";
+      }
       s = s + s1;
       free(s1);
     }
@@ -951,7 +959,7 @@ int XrdHttpReq::ProcessHTTPReq() {
   kXR_int32 l;
 
   /// If we have to add extra header information, add it here.
-  if (!hdr2cgistr.empty()) {
+  if (!m_appended_hdr2cgistr && !hdr2cgistr.empty()) {
     const char *p = strchr(resourceplusopaque.c_str(), '?');
     if (p) {
       resourceplusopaque.append("&");
@@ -963,11 +971,7 @@ int XrdHttpReq::ProcessHTTPReq() {
     resourceplusopaque.append(q);
     TRACEI(DEBUG, "Appended header fields to opaque info: '" << hdr2cgistr << "'");
     free(q);
-
-    // Once we've appended the authorization to the full resource+opaque string,
-    // reset the authz to empty: this way, any operation that triggers repeated ProcessHTTPReq
-    // calls won't also trigger multiple copies of the authz.
-    hdr2cgistr = "";
+    m_appended_hdr2cgistr = true;
     }
 
   // Verify if we have an external handler for this request
@@ -2717,6 +2721,7 @@ void XrdHttpReq::reset() {
   host = "";
   destination = "";
   hdr2cgistr = "";
+  m_appended_hdr2cgistr = false;
 
   iovP = 0;
   iovN = 0;
diff --git a/src/XrdHttp/XrdHttpReq.hh b/src/XrdHttp/XrdHttpReq.hh
index 83af74373b5..4d470d2a444 100644
--- a/src/XrdHttp/XrdHttpReq.hh
+++ b/src/XrdHttp/XrdHttpReq.hh
@@ -226,6 +226,7 @@ public:
 
   /// Additional opaque info that may come from the hdr2cgi directive
   std::string hdr2cgistr;
+  bool m_appended_hdr2cgistr;
   
   //
   // Area for coordinating request and responses to/from the bridge
