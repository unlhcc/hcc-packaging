From a807fb291cc39ef573d8014953372fe1ae7ef9f7 Mon Sep 17 00:00:00 2001
From: Brian Bockelman <bbockelm@cse.unl.edu>
Date: Tue, 28 Aug 2018 23:30:25 -0500
Subject: [PATCH 1/2] Always invoke the callback after the bridge has a
 successful process.

In fact, we should continue to invoke the callback as long as it
requests an immediate callback.

If the OFS layer causes a stall, this fixes a bug where the XrdHttp
handler was never invoked.
---
 src/XrdXrootd/XrdXrootdTransit.cc | 8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

diff --git a/src/XrdXrootd/XrdXrootdTransit.cc b/src/XrdXrootd/XrdXrootdTransit.cc
index d5b50028117..649b1450b5f 100644
--- a/src/XrdXrootd/XrdXrootdTransit.cc
+++ b/src/XrdXrootd/XrdXrootdTransit.cc
@@ -415,7 +415,13 @@ int XrdXrootdTransit::Process()
 // be deleted while a timer is outstanding as the link has been disabled. So,
 // we can reissue the request with little worry.
 //
-   if (!runALen || RunCopy(runArgs, runALen)) rc = Process2();
+   if (!runALen || RunCopy(runArgs, runALen)) {
+      do{rc = Process2();
+        if (rc == 0) {
+          rc = realProt->Process(NULL);
+        }
+      } while((rc == 0) && !runError && !runWait);
+   }
       else rc = Send(kXR_error, ioV, 2, 0);
 
 // Defer the request if need be

From 355e207c3d2bf9f0523d159dd37dbc229c81ba57 Mon Sep 17 00:00:00 2001
From: Brian Bockelman <bbockelm@cse.unl.edu>
Date: Tue, 28 Aug 2018 23:32:07 -0500
Subject: [PATCH 2/2] Use pthread_mutex_timedlock.

Uses the local pthread implementation of waiting on a lock for a
finite amount of time -- beats sleep and retry.
---
 src/XrdOfs/XrdOfsHandle.cc  | 10 +---------
 src/XrdSys/XrdSysPthread.hh |  9 +++++++++
 2 files changed, 10 insertions(+), 9 deletions(-)

diff --git a/src/XrdOfs/XrdOfsHandle.cc b/src/XrdOfs/XrdOfsHandle.cc
index 64c34e97ec7..2dda1d91b3d 100644
--- a/src/XrdOfs/XrdOfsHandle.cc
+++ b/src/XrdOfs/XrdOfsHandle.cc
@@ -503,17 +503,9 @@ do{xP = XrdOfsHanXpr::Get(); hP = xP->Handle;
   
 int XrdOfsHandle::WaitLock(void)
 {
-   int ntry = LockTries;
-
 // Try to obtain a lock within the retry parameters
 //
-   while(ntry--)
-        {if (hMutex.CondLock()) return 1;
-         if (ntry) XrdSysTimer::Wait(LockWait);
-        }
-
-// Indicate we could not get a lock
-//
+   if (hMutex.TimedLock(LockTries*LockWait)) return 1;
    return 0;
 }
 
diff --git a/src/XrdSys/XrdSysPthread.hh b/src/XrdSys/XrdSysPthread.hh
index 6de3c5d9b29..0f566426d48 100644
--- a/src/XrdSys/XrdSysPthread.hh
+++ b/src/XrdSys/XrdSysPthread.hh
@@ -146,6 +146,15 @@ inline int CondLock()
         return 1;
        }
 
+inline int TimedLock(int wait_ms)
+       {struct timespec wait;
+        clock_gettime(CLOCK_REALTIME, &wait);
+        wait.tv_nsec += wait_ms * 100000;
+        wait.tv_sec += (wait.tv_nsec / 100000000);
+        wait.tv_nsec = wait.tv_nsec % 100000000;
+        return !pthread_mutex_timedlock(&cs, &wait);
+       }
+
 inline void   Lock() {pthread_mutex_lock(&cs);}
 
 inline void UnLock() {pthread_mutex_unlock(&cs);}
